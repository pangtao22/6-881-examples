import numpy as np
from drake import lcmt_iiwa_status
from .iiwa_plan_runner import IiwaPlanRunner
from .plan_utils import *
from pydrake.examples.manipulation_station import (
    ManipulationStationHardwareInterface, IiwaCollisionModel)
from pydrake.systems.analysis import Simulator
from pydrake.systems.framework import DiagramBuilder
from pydrake.systems.meshcat_visualizer import MeshcatVisualizer, \
    MeshcatContactVisualizer
from pydrake.systems.primitives import LogOutput


class ManipulationStationSimulator:
    def __init__(self, X_WObject=None, robot_has_collision=False, 
                ):

        # Finalize manipulation station by adding manipuland.
        self.station = ManipulationStation()
        if robot_has_collision:
            self.station.SetupManipulationClassStation(
                IiwaCollisionModel.kBoxCollision)
        else:
            self.station.SetupManipulationClassStation()
        self.frames_to_draw = {"iiwa": {"iiwa_link_7"}, "gripper": {"body"}}

        if X_WObject is not None:
            foam_brick_sdf = "drake/examples/manipulation_station/models/061_foam_brick.sdf"
            self.frames_to_draw["foam_brick"] = {"base_link"}
            self.station.AddManipulandFromFile(foam_brick_sdf, X_WObject)
        self.station.Finalize()
        self.plant = self.station.get_mutable_multibody_plant()

        self.simulator = None
        self.plan_runner = None
        self.nq = 7

        # Initial pose of the object
        self.X_WObject = X_WObject

        self.meshcat_vis = None
        self.diagram = None

    def RunSimulation(self, q0_iiwa, door_angles, plan_list,
                      gripper_setpoint_list,
                      extra_time=0, real_time_rate=1.0,
                      is_visualizing=True,
                      gripper_setpoint_initial=0.025):
        """
        Constructs a Diagram that sends commands to ManipulationStation.
        @param plan_list: A list of Plans to be executed.
        @param gripper_setpoint_list: A list of gripper setpoints. Each setpoint corresponds to a Plan.
        @param extra_time: the amount of time for which commands are sent,
            in addition to the sum of the durations of all plans.
        @param real_time_rate: 1.0 means realtime; 0 means as fast as possible.
        @param q0_iiwa: initial configuration of the robot.
        @param is_visualizing: if true, adds MeshcatVisualizer to the Diagram. It should be set to False
            when running tests.
        @param sim_duration: the duration of simulation in seconds. If unset, it is set to the sum of the durations of all
            plans in plan_list plus extra_time.
        @return: logs of robot configuration and MultibodyPlant, generated by simulation.
            Logs are SignalLogger systems, whose data can be accessed by SignalLogger.data().
        """
        builder = DiagramBuilder()
        builder.AddSystem(self.station)

        # Add plan runner.
        if is_visualizing:
            print_period=1.0
        else:
            print_period=np.inf

        plan_runner = IiwaPlanRunner(
            iiwa_plans=plan_list,
            gripper_setpoint_list=gripper_setpoint_list,
            print_period=print_period,
            gripper_setpoint_initial=gripper_setpoint_initial)
        self.plan_runner = plan_runner

        iiwa_position_command_log, iiwa_position_measured_log, \
        iiwa_external_torque_log, iiwa_velocity_estimated_log = \
            self.ConnectPortsAndAddLoggers(builder, self.station, plan_runner)

        plant_state_log = LogOutput(
            self.station.GetOutputPort("plant_continuous_state"), builder)
        plant_state_log.set_publish_period(0.01)

        if is_visualizing:
            # Add meshcat visualizer
            scene_graph = self.station.get_mutable_scene_graph()
            viz = MeshcatVisualizer(scene_graph,
                                    zmq_url="tcp://127.0.0.1:6000",
                                    frames_to_draw=self.frames_to_draw,
                                    frames_opacity=0.8)
            self.meshcat_vis = viz
            builder.AddSystem(viz)
            builder.Connect(self.station.GetOutputPort("pose_bundle"),
                            viz.GetInputPort("lcm_visualization"))

            contact_viz = MeshcatContactVisualizer(
                meshcat_viz=viz, plant=self.plant)
            builder.AddSystem(contact_viz)
            builder.Connect(
                self.station.GetOutputPort("pose_bundle"),
                contact_viz.GetInputPort("pose_bundle"))
            builder.Connect(
                self.station.GetOutputPort("contact_results"),
                contact_viz.GetInputPort("contact_results"))

        # build diagram
        diagram = builder.Build()
        self.diagram = diagram
        # RenderSystemWithGraphviz(diagram)

        # construct simulator
        simulator = Simulator(diagram)
        self.simulator = simulator

        context = diagram.GetMutableSubsystemContext(
            self.station, simulator.get_mutable_context())

        # set initial state of the robot
        self.station.SetIiwaPosition(context, q0_iiwa)
        self.station.SetIiwaVelocity(context, np.zeros(7))
        self.station.SetWsgPosition(context, 0.03)
        self.station.SetWsgVelocity(context, 0)

        # set initial hinge angles of the cupboard.
        # setting hinge angle to exactly 0 or 90 degrees will result in
        # intermittent contact with small contact forces between the door and
        # the cupboard body.
        left_hinge_joint = self.plant.GetJointByName("left_door_hinge")
        left_hinge_joint.set_angle(
            context=self.station.GetMutableSubsystemContext(
                self.plant, context),
            angle=door_angles[0])

        right_hinge_joint = self.plant.GetJointByName("right_door_hinge")
        right_hinge_joint.set_angle(
            context=self.station.GetMutableSubsystemContext(self.plant,
                                                            context),
            angle=door_angles[1])

        simulator.set_publish_every_time_step(False)
        simulator.set_target_realtime_rate(real_time_rate)

        # calculate starting time for all plans.
        t_plan = GetPlanStartingTimes(plan_list)
        sim_duration = t_plan[-1] + extra_time
        if is_visualizing:
            print("simulation duration", sim_duration)
            print("plan starting times\n", t_plan)

        self.SetInitialPlanRunnerState(plan_runner, simulator, diagram)
        simulator.Initialize()
        simulator.AdvanceTo(sim_duration)

        return (iiwa_position_command_log, iiwa_position_measured_log,
                iiwa_external_torque_log, iiwa_velocity_estimated_log,
                plant_state_log, t_plan)

    def RunRealRobot(self, plan_list, gripper_setpoint_list, extra_time=2.0):
        """
        Constructs a Diagram that sends commands to
            ManipulationStationHardwareInterface.
        @param plan_list: A list of Plans to be executed.
        @param gripper_setpoint_list: A list of gripper setpoints. Each setpoint
            corresponds to a Plan.
        @param sim_duration: the duration of simulation in seconds. If unset,
            it is set to the sum of the durations of all plans in plan_list
            plus extra_time.
        @param extra_time: the amount of time for which commands are sent, in
            addition to the duration of all plans.
        @param is_plan_runner_diagram: True: use the diagram version of
            PlanRunner; False: use the leaf version of PlanRunner.
        @return: logs of robot configuration and torque, decoded from LCM
            messges sent by the robot's driver. Logs are SignalLogger
            systems, whose data can be accessed by SignalLogger.data().
        """
        builder = DiagramBuilder()
        camera_ids = ["805212060544"]
        station_hardware = ManipulationStationHardwareInterface(camera_ids)
        station_hardware.Connect(wait_for_cameras=False)
        builder.AddSystem(station_hardware)

        # Add plan runner.
        plan_runner = IiwaPlanRunner(
            iiwa_plans=plan_list,
            gripper_setpoint_list=gripper_setpoint_list,
            print_period=np.inf)

        iiwa_position_command_log, iiwa_position_measured_log, \
        iiwa_external_torque_log, iiwa_velocity_estimated_log = \
            self.ConnectPortsAndAddLoggers(
                builder, station_hardware, plan_runner)

        # build diagram
        diagram = builder.Build()
        # RenderSystemWithGraphviz(diagram)

        # construct simulator
        simulator = Simulator(diagram)
        self.simulator = simulator

        simulator.set_target_realtime_rate(1.0)
        simulator.set_publish_every_time_step(False)

        t_plan = GetPlanStartingTimes(plan_list)
        sim_duration = t_plan[-1] + extra_time
        print("simulation duration", sim_duration)
        print("plan starting times\n", t_plan)

        # set initial command to be the same as current robot joint angles.
        q0 = self.GetCurrentJointAngles()
        plan_runner_context = \
            diagram.GetMutableSubsystemContext(
                plan_runner, simulator.get_mutable_context())

        state = plan_runner_context.get_mutable_discrete_state_vector().get_mutable_value()
        state[:self.nq] = q0

        simulator.Initialize()
        simulator.AdvanceTo(sim_duration)

        return (iiwa_position_command_log, iiwa_position_measured_log,
                iiwa_velocity_estimated_log, iiwa_external_torque_log, t_plan)

    @staticmethod
    def GetCurrentJointAngles():
        import lcm
        q0 = np.zeros(7)

        def HandleIiwaStatusMessage(channel, data):
            msg = lcmt_iiwa_status.decode(data)
            q0[:] = msg.joint_position_measured

        lc = lcm.LCM()
        lc.subscribe("IIWA_STATUS", HandleIiwaStatusMessage)
        lc.handle()

        return q0

    @staticmethod
    def ConnectPortsAndAddLoggers(builder, station, plan_runner):
        builder.AddSystem(plan_runner)
        builder.Connect(plan_runner.GetOutputPort("gripper_setpoint"),
                        station.GetInputPort("wsg_position"))
        builder.Connect(plan_runner.GetOutputPort("force_limit"),
                        station.GetInputPort("wsg_force_limit"))
        builder.Connect(plan_runner.GetOutputPort("iiwa_position_command"),
                        station.GetInputPort("iiwa_position"))
        builder.Connect(plan_runner.GetOutputPort("iiwa_torque_command"),
                        station.GetInputPort("iiwa_feedforward_torque"))

        builder.Connect(station.GetOutputPort("iiwa_position_measured"),
                        plan_runner.GetInputPort("iiwa_position"))
        builder.Connect(station.GetOutputPort("iiwa_position_commanded"),
                        plan_runner.GetInputPort("iiwa_position_cmd"))
        builder.Connect(station.GetOutputPort("iiwa_velocity_estimated"),
                        plan_runner.GetInputPort("iiwa_velocity"))
        builder.Connect(station.GetOutputPort("iiwa_torque_external"),
                        plan_runner.GetInputPort("iiwa_torque_external"))

        # Add loggers
        iiwa_position_command_log = LogOutput(
            plan_runner.GetOutputPort("iiwa_position_command"), builder)
        iiwa_position_command_log.set_publish_period(0.01)

        iiwa_external_torque_log = LogOutput(
            station.GetOutputPort("iiwa_torque_external"), builder)
        iiwa_external_torque_log.set_publish_period(0.01)

        iiwa_position_measured_log = LogOutput(
            station.GetOutputPort("iiwa_position_measured"), builder)
        iiwa_position_measured_log.set_publish_period(0.01)

        iiwa_velocity_estimated_log = LogOutput(
            station.GetOutputPort("iiwa_velocity_estimated"), builder)
        iiwa_velocity_estimated_log.set_publish_period(0.01)

        return (iiwa_position_command_log, iiwa_position_measured_log,
                iiwa_external_torque_log, iiwa_velocity_estimated_log)

    @staticmethod
    def SetInitialPlanRunnerState(plan_runner, simulator, diagram):
        """
        Sets iiwa_position_command, part of the discrete state of plan_runner,
            to the initial state of the robot at t=0.
        Otherwise the position command at t=0 is 0, driving the robot to its
            upright position, usually resulting in huge velocity.
        Calling this function after simulator.Initialize() puts a column of
            zeros at the beginning of iiwa_position_command_log, but that
            zero command doesn't seem to be sent to the robot.
        """
        plan_runner_context = \
            diagram.GetMutableSubsystemContext(plan_runner,
                                               simulator.get_mutable_context())
        iiwa_position_input_port = plan_runner.GetInputPort("iiwa_position")
        q0_iiwa = plan_runner.EvalVectorInput(
            plan_runner_context,
            iiwa_position_input_port.get_index()).get_value()
        for i in range(7):
            plan_runner_context.get_mutable_discrete_state(0).SetAtIndex(
                i, q0_iiwa[i])


